/*
  iSYS4001 Radar Sensor - Complete Example
  -----------------------------------------
  ESP32 interface with iSYS4001 radar sensor
  
  Features:
  - Factory reset to ensure clean state
  - Multiple target filter configuration
  - Real-time target detection (16-bit and 32-bit)
  - Debug output and error handling
  
  Wiring: Radar TX→GPIO16, Radar RX→GPIO17, GND shared
*/

#include "iSYS4001.h"

// Configuration
iSYS4001 radar(Serial2, 115200);
iSYSTargetList_t targetList16, targetList32;
const uint8_t DEVICE_ADDR = 0x80;
const uint32_t TIMEOUT_MS = 300;
const bool DEBUG_ENABLED = true;

void setup() {
  Serial.begin(115200);
  while (!Serial) { delay(10); }
  
  Serial.println("=== iSYS4001 Radar Complete Example ===");
  Serial.printf("Device Address: 0x%02X\n", DEVICE_ADDR);
  
  // Enable debug output
  if (DEBUG_ENABLED) {
    radar.setDebug(Serial, true);
    Serial.println("Debug enabled");
  }
  
  // Initialize radar communication
  Serial2.begin(115200, SERIAL_8N1, 16, 17);
  while (Serial2.available()) { Serial2.read(); } // Flush
  delay(500);
  
  // Step 1: Start acquisition
  Serial.println("\n--- Step 1: Start Acquisition ---");
  iSYSResult_t startRes = radar.iSYS_startAcquisition(DEVICE_ADDR, TIMEOUT_MS);
  if (startRes == ERR_OK) {
    Serial.println("Acquisition started successfully");
  } else {
    Serial.printf("✗ Start acquisition failed: 0x%02X\n", startRes);
  }
  
  Serial.println("\n=== Ready - Starting Target Detection ===\n");
  
  // Step 2: Configure multiple target filter
  Serial.println("\n--- Step 2: Multiple Target Filter Setup ---");
  iSYSResult_t filterRes = radar.iSYS_setMultipleTargetFilter(ISYS_OUTPUT_1, DEVICE_ADDR, TIMEOUT_MS);
  if (filterRes == ERR_OK) {
    Serial.println("Multiple target filter configured (ISYS_OFF)");
  } else {
    Serial.printf("Multiple target filter failed: 0x%02X\n", filterRes);
  }
  



  // Step 3: Seset the settings
  Serial.println("\n--- Step 3: Save Settings ---");
  iSYSResult_t SaveRes = radar.saveAllSettings(DEVICE_ADDR, TIMEOUT_MS);
  if (SaveRes == ERR_OK) {
    Serial.println("Settings saved successfully");
  } else {
    Serial.printf("Saving settings failed: 0x%02X\n", SaveRes);
  }
  delay(1000);

}

void loop() {
  // Clear stale data
  while (Serial2.available()) { Serial2.read(); }
  
  Serial.println("--- Target Detection Cycle ---");
  
  // Test 16-bit target list
  Serial.println("Requesting 16-bit target list...");
  iSYSResult_t res16 = radar.getTargetList16(&targetList16, DEVICE_ADDR, TIMEOUT_MS, ISYS_OUTPUT_1);
  if (res16 == ERR_OK && targetList16.error.iSYSTargetListError == TARGET_LIST_OK) {
    Serial.printf("✓ 16-bit: %u targets detected\n", targetList16.nrOfTargets);
    displayTargets(&targetList16, "16-bit");
  } else {
    Serial.printf("✗ 16-bit detection failed: 0x%02X\n", res16);
  }
  
  delay(200);
  
  // Test 32-bit target list
  Serial.println("Requesting 32-bit target list...");
  iSYSResult_t res32 = radar.getTargetList32(&targetList32, DEVICE_ADDR, TIMEOUT_MS, ISYS_OUTPUT_1);
  if (res32 == ERR_OK && targetList32.error.iSYSTargetListError == TARGET_LIST_OK) {
    Serial.printf("✓ 32-bit: %u targets detected\n", targetList32.nrOfTargets);
    displayTargets(&targetList32, "32-bit");
  } else {
    Serial.printf("✗ 32-bit detection failed: 0x%02X\n", res32);
  }
  
  Serial.println("--- End Cycle ---\n");
  delay(1000); // 1 second between cycles
}

void displayTargets(iSYSTargetList_t *targetList, const char* type) {
  if (targetList->nrOfTargets > 0) {
    for (uint16_t i = 0; i < targetList->nrOfTargets && i < MAX_TARGETS; i++) {
      Serial.printf("  %s T%u: Sig=%.1fdB Vel=%.2fm/s Range=%.2fm Ang=%.1f°\n",
                   type,
                   i + 1,
                   targetList->targets[i].signal,
                   targetList->targets[i].velocity,
                   targetList->targets[i].range,
                   targetList->targets[i].angle);
    }
  } else {
    Serial.printf("  %s: No targets detected\n", type);
  }
  
  if (targetList->clippingFlag) {
    Serial.printf("  %s: Data clipping detected!\n", type);
  }
}
